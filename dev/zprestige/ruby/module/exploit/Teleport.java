//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\user\Desktop\1.12 stable mappings"!

//Decompiled by Procyon!

package dev.zprestige.ruby.module.exploit;

import dev.zprestige.ruby.module.*;
import dev.zprestige.ruby.settings.impl.*;
import org.lwjgl.input.*;
import net.minecraft.network.play.client.*;
import net.minecraft.network.*;
import dev.zprestige.ruby.util.*;
import dev.zprestige.ruby.*;
import net.minecraft.entity.player.*;

public class Teleport extends Module
{
    public final Slider force;
    public final Slider attempts;
    public final Slider distance;
    public final Key enemyTpKey;
    public final Key oneBlockKey;
    public final Switch hold;
    public final Switch airGlide;
    public final Slider verticalGlideSpeed;
    public boolean executed;
    
    public Teleport() {
        this.force = this.Menu.Slider("Force", 0.1f, 10.0f);
        this.attempts = this.Menu.Slider("Attempts", 1, 20);
        this.distance = this.Menu.Slider("Distance", 1, 50);
        this.enemyTpKey = this.Menu.Key("Enemy Tp Key", 0);
        this.oneBlockKey = this.Menu.Key("One Block Key", 0);
        this.hold = this.Menu.Switch("Hold");
        this.airGlide = this.Menu.Switch("Air Glide");
        this.verticalGlideSpeed = this.Menu.Slider("Vertical Glide Speed", 0.1f, 100.0f);
    }
    
    @Override
    public void onTick() {
        if (this.enemyTpKey.GetKey() == 0 || !Keyboard.isKeyDown(this.enemyTpKey.GetKey())) {
            if (this.airGlide.GetSwitch()) {
                this.mc.player.motionY = -0.01;
                final double currY = this.mc.player.posY;
                if (this.mc.gameSettings.keyBindJump.isKeyDown()) {
                    for (int i = 0; i < this.attempts.GetSlider(); ++i) {
                        this.mc.player.setPosition(this.mc.player.posX, currY + this.verticalGlideSpeed.GetSlider() / 100.0f, this.mc.player.posZ);
                    }
                }
                if (this.mc.gameSettings.keyBindSneak.isKeyDown()) {
                    for (int i = 0; i < this.attempts.GetSlider(); ++i) {
                        this.mc.player.setPosition(this.mc.player.posX, currY - this.verticalGlideSpeed.GetSlider() / 100.0f, this.mc.player.posZ);
                    }
                }
            }
            if (this.oneBlockKey.GetKey() != 0 && Keyboard.isKeyDown(this.oneBlockKey.GetKey())) {
                for (int j = 0; j < this.attempts.GetSlider(); ++j) {
                    this.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(this.mc.player.posX, this.mc.player.posY - this.force.GetSlider() / 10.0f, this.mc.player.posZ, false));
                    switch (this.mc.player.getHorizontalFacing()) {
                        case NORTH: {
                            this.sendPacket(0.0, 0.0, -1.0, true);
                            break;
                        }
                        case EAST: {
                            this.sendPacket(1.0, 0.0, 0.0, true);
                            break;
                        }
                        case SOUTH: {
                            this.sendPacket(0.0, 0.0, 1.0, true);
                            break;
                        }
                        case WEST: {
                            this.sendPacket(-1.0, 0.0, 0.0, true);
                            break;
                        }
                    }
                }
            }
            if (this.mc.gameSettings.keyBindAttack.isKeyDown()) {
                if (!this.executed || this.hold.GetSwitch()) {
                    for (int j = 0; j < this.attempts.GetSlider(); ++j) {
                        this.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(this.mc.player.posX, this.mc.player.posY - this.force.GetSlider() / 10.0f, this.mc.player.posZ, false));
                        switch (this.mc.player.getHorizontalFacing()) {
                            case NORTH: {
                                this.sendPacket(0.0, 0.0, -this.distance.GetSlider(), true);
                                break;
                            }
                            case EAST: {
                                this.sendPacket(this.distance.GetSlider(), 0.0, 0.0, true);
                                break;
                            }
                            case SOUTH: {
                                this.sendPacket(0.0, 0.0, this.distance.GetSlider(), true);
                                break;
                            }
                            case WEST: {
                                this.sendPacket(-this.distance.GetSlider(), 0.0, 0.0, true);
                                break;
                            }
                        }
                        this.executed = true;
                    }
                }
            }
            else {
                this.executed = false;
            }
            return;
        }
        final EntityPlayer entityPlayer = EntityUtil.getTarget(200.0f);
        if (entityPlayer == null) {
            Ruby.chatManager.sendMessage("No target found unable to teleport.");
            return;
        }
        for (int k = 0; k < this.attempts.GetSlider(); ++k) {
            this.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(this.mc.player.posX, this.mc.player.posY - this.force.GetSlider() / 10.0f, this.mc.player.posZ, false));
            this.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(entityPlayer.posX, this.mc.player.posY, entityPlayer.posZ, true));
        }
    }
    
    public void sendPacket(final double x, final double y, final double z, final boolean onGroundIn) {
        this.mc.player.connection.sendPacket((Packet)new CPacketPlayer.Position(this.mc.player.posX + x, this.mc.player.posY + y, this.mc.player.posZ + z, onGroundIn));
    }
}
